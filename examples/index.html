
<!DOCTYPE html> 
<html lang="en"> 
    <head>
        <title>Brains@Play Test</title>
        <link rel='stylesheet' href='./style.css'>

        <script src="./index.js" type="module"></script>
        <!-- <script src="./multithreaded/index.js" type="module"></script> -->
        
    </head>
    <body>


        <!-- SHADERS -->
    <!-- Desert Ground -->
    <script type="x-shader/x-vertex" id="desertGroundVertexShader">
        uniform float iTime;
        // uniform float uBigWavesSpeed;
        uniform float uBigWavesElevation;
        uniform vec2 uBigWavesFrequency;
        uniform float uSmallWavesElevation;
        uniform float uSmallWavesFrequency;
        uniform float uSmallWavesSpeed;
        uniform float uSmallIterations;
        uniform float uFogRadius;
        uniform float uFogDropoff;
        uniform float uRiverOffset;
        uniform float uRiverWidth;
        varying float vElevation;
        varying float vFog;
        
        // Classic Perlin 3D Noise 
        // by Stefan Gustavson
        //
        vec4 permute(vec4 x)
        {
            return mod(((x*34.0)+1.0)*x, 289.0);
        }
        vec4 taylorInvSqrt(vec4 r)
        {
            return 1.79284291400159 - 0.85373472095314 * r;
        }
        vec3 fade(vec3 t)
        {
            return t*t*t*(t*(t*6.0-15.0)+10.0);
        }
        
        float cnoise(vec3 P)
        {
            vec3 Pi0 = floor(P); // Integer part for indexing
            vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
            Pi0 = mod(Pi0, 289.0);
            Pi1 = mod(Pi1, 289.0);
            vec3 Pf0 = fract(P); // Fractional part for interpolation
            vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
            vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
            vec4 iy = vec4(Pi0.yy, Pi1.yy);
            vec4 iz0 = Pi0.zzzz;
            vec4 iz1 = Pi1.zzzz;
        
            vec4 ixy = permute(permute(ix) + iy);
            vec4 ixy0 = permute(ixy + iz0);
            vec4 ixy1 = permute(ixy + iz1);
        
            vec4 gx0 = ixy0 / 7.0;
            vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
            gx0 = fract(gx0);
            vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
            vec4 sz0 = step(gz0, vec4(0.0));
            gx0 -= sz0 * (step(0.0, gx0) - 0.5);
            gy0 -= sz0 * (step(0.0, gy0) - 0.5);
        
            vec4 gx1 = ixy1 / 7.0;
            vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
            gx1 = fract(gx1);
            vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
            vec4 sz1 = step(gz1, vec4(0.0));
            gx1 -= sz1 * (step(0.0, gx1) - 0.5);
            gy1 -= sz1 * (step(0.0, gy1) - 0.5);
        
            vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
            vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
            vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
            vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
            vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
            vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
            vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
            vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
        
            vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
            g000 *= norm0.x;
            g010 *= norm0.y;
            g100 *= norm0.z;
            g110 *= norm0.w;
            vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
            g001 *= norm1.x;
            g011 *= norm1.y;
            g101 *= norm1.z;
            g111 *= norm1.w;
        
            float n000 = dot(g000, Pf0);
            float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
            float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
            float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
            float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
            float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
            float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
            float n111 = dot(g111, Pf1);
        
            vec3 fade_xyz = fade(Pf0);
            vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
            vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
            float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
            return 2.2 * n_xyz;
        }
        float random (vec2 st) {
            return fract(sin(dot(st.xy,
                                 vec2(12.9898,78.233)))*
                43758.5453123);
        }
        
        void main() {
            vec4 modelPosition = modelMatrix * vec4(position, 1.0);
            //Elevation
            // float elevation = sin(model)
            // modelPosition.y += uBigWavesElevation * sin(modelPosition.x);
            // modelPosition.y += sin(modelPosition.z);
        
            float x = modelPosition.x;
            
            //y = mix(rand(i), rand(i + 1.0), smoothstep(0.,1.,f));
        
            float elevation = 0.0;
            vec3 artifactEradicator = clamp(modelPosition.xyz,vec3(0.3),vec3(999999.9));
            elevation += clamp(cnoise(artifactEradicator.xyz / (0.2 + artifactEradicator.xyz)),0.48,1.0);
            
        
            float center = cnoise(modelPosition.xyz/7.0) + uRiverOffset;
            float width = uRiverWidth;
            float falloff = 2.0; 
            float leftBank = center - (width/2.0);
            float rightBank = center +(width/2.0);
            float river = smoothstep(leftBank - (0.3 * cnoise(modelPosition.xyz)),leftBank+falloff,modelPosition.x);
            river -= smoothstep(rightBank-falloff, rightBank + (0.3 * cnoise(modelPosition.xyz)),modelPosition.x);
        
        
        
            elevation -= river;
            for(float i = 1.0; i <= uSmallIterations; i++)
            {
                elevation -= abs(cnoise(vec3(modelPosition.xz * uSmallWavesFrequency * i, iTime * uSmallWavesSpeed)) * uSmallWavesElevation / i);
            }
        
            modelPosition.y += elevation;
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectedPosition = projectionMatrix * viewPosition;
        
            gl_Position = projectedPosition;
        
            //varying
            vFog = uFogRadius - distance(vec2(0.0,0.0),modelPosition.xz);
            // vFog += mix(0.0,1.0,(uFogRadius + uFogDropoff) / uFogRadius) *(uFogRadius + uFogDropoff - distance(vec2(0.0,0.0),modelPosition.xz));
            // vFog = clamp(uFogRadius - vFog, 0.0,1.0);
            vElevation = elevation / uBigWavesElevation;
        
        }
    </script>

    <script type="x-shader/x-vertex" id="desertGroundFragmentShader">
        uniform vec3 uDepthColor;
        uniform vec3 uSurfaceColor;
        uniform float uColorOffset;
        uniform float uColorMultiplier;
        
        varying float vElevation;
        varying float vFog;
        void main(){
        
            float mixStrength = vElevation * uColorMultiplier + uColorOffset;
            vec3 color = mix(uDepthColor,uSurfaceColor,mixStrength);
            
            gl_FragColor = vec4(color,vFog * clamp(vElevation,0.0,1.0));
            // gl_FragColor = vec4(color,1.0);
        }
    </script>

    <!-- River -->
    <script type="x-shader/x-vertex" id="invisisphereVertexShader">

        attribute float mass;

        uniform float iTime;
        uniform float uSpeedModifier;
        varying float vMass;
        uniform sampler2D uImage;
        
        varying vec2 vCircleSpace;
        varying float vDepth;
        float random (in vec2 st) {
            return fract(sin(dot(st.xy,
            vec2(12.9898,78.233)))*
            43758.5453123);
        }
        
        void main() {
            float speed = clamp(0.03 + uSpeedModifier, 0.0, 2.0);
        
            // position.x += iTime;
            vMass = mass;
            vec3 modifiedPosition = position;
            modifiedPosition.x = (modifiedPosition.x - iTime * mass * speed) - (floor(modifiedPosition.x - iTime * mass * speed));
                // modifiedPosition.x = (modifiedPosition.x - iTime * mass * speed);
            // modifiedPosition.x += iTime;
            vec4 modelPosition = modelMatrix * vec4(modifiedPosition, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectedPosition = projectionMatrix * viewPosition;
            gl_PointSize = 15.0 * (1.0 - mass);
            gl_Position = projectedPosition;
            //used for sun version
            vCircleSpace = position.xy;
            // vCircleSpace = modifiedPosition.xy;
            vDepth = position.z;
        }
    </script>

    <script type="x-shader/x-vertex" id="invisisphereFragmentShader">
        varying float vMass;
        varying vec2 vCircleSpace;
        // varying float vDepth;
        uniform float iTime;
        uniform float uColorChange;
        
        float map(float value, float min1, float max1, float min2, float max2) {
          return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        }
        
        
        float circle(in vec2 _st, in float _radius){
            vec2 dist = _st-vec2(0.5);
            return 1.-smoothstep(_radius-(_radius*0.01),
                                 _radius+(_radius*0.01),
                                 dot(dist,dist)*4.0);
        }
        
        float slashA(in vec2 _st, in float _y, in float _bump){
            return step(_st.y,map(_st.x,0.0,1.0,_y,_y+_bump) );
        }
        
        
        // book of shaders random from fbm chapter
        float random (in vec2 st) {
            return fract(sin(dot(st.xy,
            vec2(12.9898,78.233)))*
            43758.5453123);
        }
        
        
        // Quilez's 2D simplex noise https://www.shadertoy.com/view/Msf3WH
        // originally had issue with tiling, but Mike Bostock's sketch and the book of shaders chapter on noise helped me figure it out
        // https://observablehq.com/@mbostock/domain-warping
        vec2 hash( vec2 p ) // replace this by something better
        {
            p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }
        float noise( in vec2 p )
        {
            const float K1 = 0.366025404; // (sqrt(3)-1)/2;
            const float K2 = 0.211324865; // (3-sqrt(3))/6;
        
            vec2  i = floor( p + (p.x+p.y)*K1 );
            vec2  a = p - i + (i.x+i.y)*K2;
            float m = step(a.y,a.x);
            vec2  o = vec2(m,1.0-m);
            vec2  b = a - o + K2;
            vec2  c = a - 1.0 + 2.0*K2;
            vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            return dot( n, vec3(70.0) );
        }
            #define OCTAVES 6
        float fbm (in vec2 st) {
            // Initial values
            float value = 0.0;
            float amplitude = .5;
            float frequency = 0.;
            //
            // Loop of octaves
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * noise(st);
                st *= 2.;
                amplitude *= .5;
            }
            return value;
        }
        
        
        void main(){
         // vec2 st = gl_FragCoord.xy/u_resolution.xy;
            // vec2 st = vUv.xy/5.0;
            vec2 st = vCircleSpace/9.0;
            // st.xy += vDepth;
            // st.x *= u_resolution.x/u_resolution.y;
            vec3 color = vec3(0.0);
            // determines size
            vec2 p = st*3.;
        
            float circleRadius = 0.40;
            float circleWidth = 0.01;
            float rbDiff = 0.40;
            float circleBrightnessBump = 0.05;
        
        
            // // river flow strength
            p.x += iTime * 0.001;
            // p.x -= iTime * 0.5 * (0.9  * circle(vUv,circleRadius-circleWidth));
        
            // undercurrent relative velocity
            float t1 = iTime * -0.05;
            // river relative velocity
            float t2 = iTime * 0.001;
            // pollution relative velocity
            float t3 = iTime * 0.1;
            vec2 q = p + t1;
            float s = fbm(p + t3);
            float r = fbm(p + t2 + s);
            // so this is where is ressembles the canonical quilez technique
            color += fbm(q + r);
            // bump up brightness a smidgen
            color += 0.25;
            color.r +=  s + 0.08;
            // note that r here isn't red, it's river as modulated by undercurrent
            color.b += r + 0.2;
            // color.r = clamp(color.r,0.1,0.9);
            color.b = clamp(color.b,0.1,0.5);
            // pollution as opposite of undercurrent color (couldnt use q without more operations)
            color.g += s/1.5;
            // color.g = clamp(color.g,color.b,0.8);
            color.r += 1.0;
            color.g += 0.2 * slashA(st, 0.8,0.2);
            // color.b += slashA(st, 0.12,0.2) - slashA(st, 0.07,0.2);
            // color.g -= 0.2 * ( slashA(st, 0.12,0.2) - slashA(st, 0.07,0.2));
                color += circle(vCircleSpace, 0.8) - circle(vCircleSpace, 0.77) ;
            color *= circle(vCircleSpace, 0.8) * step(st.y,0.75);
            // gl_FragColor = vec4(color,vMass *  2.1 * vDepth + .05 );
        
            vec3 color2 = vec3(0.3);
            color2 += fbm(q + r);
            // bump up brightness a smidgen
            color2 += 0.25;
            color2.r +=  s + 0.18;
            // note that r here isn't red, it's river as modulated by undercurrent
            color2.b += r + 0.5;
            // pollution as opposite of undercurrent color (couldnt use q without more operations)
            color2.g += s/2.5;
            gl_FragColor = vec4(mix(color,color2,uColorChange),vMass *  2.1 + .05 );
        }
    </script>

    <!-- Particles -->
    <script type="x-shader/x-vertex" id="particlesVertexShader">

        attribute float mass;

        uniform float iTime;
        uniform float uSpeedModifier;
        varying float vMass;
        uniform sampler2D uImage;
        
        varying vec2 vCircleSpace;
        varying float vDepth;
        float random (in vec2 st) {
            return fract(sin(dot(st.xy,
            vec2(12.9898,78.233)))*
            43758.5453123);
        }
        
        void main() {
            float speed = clamp(0.03 + uSpeedModifier, 0.0, 2.0);
        
            // position.x += iTime;
            vMass = mass;
            vec3 modifiedPosition = position;
            modifiedPosition.x = (modifiedPosition.x - iTime * mass * speed) - (floor(modifiedPosition.x - iTime * mass * speed));
                // modifiedPosition.x = (modifiedPosition.x - iTime * mass * speed);
            // modifiedPosition.x += iTime;
            vec4 modelPosition = modelMatrix * vec4(modifiedPosition, 1.0);
            vec4 viewPosition = viewMatrix * modelPosition;
            vec4 projectedPosition = projectionMatrix * viewPosition;
            gl_PointSize = 15.0 * (1.0 - mass);
            gl_Position = projectedPosition;
            //used for sun version
            vCircleSpace = position.xy;
            // vCircleSpace = modifiedPosition.xy;
            vDepth = position.z;
        }
    </script>

    <script type="x-shader/x-vertex" id="particlesFragmentShader">
        varying float vMass;
        varying vec2 vCircleSpace;
        varying float vDepth;
        uniform float iTime;
        uniform float uVerdant;
        
        
        float map(float value, float min1, float max1, float min2, float max2) {
          return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        }
        
        
        float circle(in vec2 _st, in float _radius){
            vec2 dist = _st-vec2(0.5);
            return 1.-smoothstep(_radius-(_radius*0.01),
                                 _radius+(_radius*0.01),
                                 dot(dist,dist)*4.0);
        }
        
        float slashA(in vec2 _st, in float _y, in float _bump){
            return step(_st.y,map(_st.x,0.0,1.0,_y,_y+_bump) );
        }
        
        
        // book of shaders random from fbm chapter
        float random (in vec2 st) {
            return fract(sin(dot(st.xy,
            vec2(12.9898,78.233)))*
            43758.5453123);
        }
        
        
        // Quilez's 2D simplex noise https://www.shadertoy.com/view/Msf3WH
        // originally had issue with tiling, but Mike Bostock's sketch and the book of shaders chapter on noise helped me figure it out
        // https://observablehq.com/@mbostock/domain-warping
        vec2 hash( vec2 p ) // replace this by something better
        {
            p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }
        float noise( in vec2 p )
        {
            const float K1 = 0.366025404; // (sqrt(3)-1)/2;
            const float K2 = 0.211324865; // (3-sqrt(3))/6;
        
            vec2  i = floor( p + (p.x+p.y)*K1 );
            vec2  a = p - i + (i.x+i.y)*K2;
            float m = step(a.y,a.x);
            vec2  o = vec2(m,1.0-m);
            vec2  b = a - o + K2;
            vec2  c = a - 1.0 + 2.0*K2;
            vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            return dot( n, vec3(70.0) );
        }
            #define OCTAVES 6
        float fbm (in vec2 st) {
            // Initial values
            float value = 0.0;
            float amplitude = .5;
            float frequency = 0.;
            //
            // Loop of octaves
            for (int i = 0; i < OCTAVES; i++) {
                value += amplitude * noise(st);
                st *= 2.;
                amplitude *= .5;
            }
            return value;
        }
        
        
        void main(){
         // vec2 st = gl_FragCoord.xy/u_resolution.xy;
            // vec2 st = vUv.xy/5.0;
            vec2 st = vCircleSpace/9.0;
            // st.xy += vDepth;
            // st.x *= u_resolution.x/u_resolution.y;
            vec3 color = vec3(0.0);
            // determines size
            vec2 p = st*3.;
        
            float circleRadius = 0.40;
            float circleWidth = 0.01;
            float rbDiff = 0.40;
            float circleBrightnessBump = 0.05;
        
        
            // // river flow strength
            p.x += iTime * 0.001;
            // p.x -= iTime * 0.5 * (0.9  * circle(vUv,circleRadius-circleWidth));
        
            // undercurrent relative velocity
            float t1 = iTime * -0.05;
            // river relative velocity
            float t2 = iTime * 0.001;
            // pollution relative velocity
            float t3 = iTime * 0.1;
            vec2 q = p + t1;
            float s = fbm(p + t3);
            float r = fbm(p + t2 + s);
            // so this is where is ressembles the canonical quilez technique
            color += fbm(q + r);
        
            // Bias towards canary yellow
            color.r = 1.0*clamp(uVerdant,0.0,1.0);
            color.g = 1.0*clamp(uVerdant,0.0,1.0);
            color.b = 0.6*clamp(uVerdant,0.0,1.0);
            gl_FragColor = vec4(color, clamp(uVerdant* vMass *  2.1 * vDepth,.05,.9) );
        }
    </script>
    
    </body>
</html>
        